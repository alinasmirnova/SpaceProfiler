# SpaceProfiler
Сделано:
- параллельная загрузка дерева 
- корректная реакция на файлы без доступа
- простой UI с отображением фактических размеров, группировкой файлов, подсвечиванием крупных сущностей
- иконки меняются в зависимости от состояния элемента (открытая-закрытая папка, пустой файл)
- отслеживание изменений на диске:
  - добавление
  - изменение файлов
  - удаление
  - перемещение
  - смена прав доступа
- тесты на загрузку дерева, отслеживание изменений, добавление файлов

В первую очередь:
1. Реагировать на удаление корня
2. Глобальная обработка ошибок
3. Отображать лоадер
4. Сортировка узлов по размеру
5. Сделать бенчмарк на загрузку большой папки с диска
6. Принять решение, нужно ли параллелить загрузку дерева с диска и сколько потоков лучше брать
7. Прокачать Readme
8. Отображать недоступные папки и файлы
9. Оптимизировать обновление детей и подсчёт процентов для Directory и FileContainer 

Во вторую очередь
1. Красивая табличка = починить выравнивание столбцов, добавить названия столбцов (?)
2. Контекстное меню с переходом в Explorer
3. Удаление через контекстное меню
4. Прогресс загрузки элемента 
5. Визуализация процента от родителя

Проверить:
- отображение файла в корне C: на 200 символов в названии
- загрузка диска С:
- изменение прав доступа
- закрытие программы до окончания загрузки с диска

Оставить на будущее:
1. Логирование
2. Размер файла на диске
3. Оптимизировать rename, чтобы не Delete+Create
4. Удаление из дерева без локов

Куча мыслей:
- можно добавить исключение определенных папок. Например, папка Windows большая, часто меняется (tmp файлы), а чистить ты её вряд ли будешь. Но нужно поизучать. Возможно стоит не прям исключать, а Watcher для них не включать.
- возможно create-delete lock всё-таки нужен. Если баг будет проявляться только на нескольких разгребаторах, то стоит об этом подумать.
- можно сделать ретраи на обработку узлов на случай исключений
- GetDirectoryName сейчас работает не оптимально, много строчек создаёт
- можно сделать группировку папок, чтобы ускорить для них сортировку, но надо подумать, как лучше
- entry.GetSize выглядит очень странно